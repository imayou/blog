---
layout: 分布式
title: 分布式一些总结
date: 2019-05-8 10:16:22
tags: 分布式
---
#### 使用分布式系统主要有两方面原因
* 增大系统容量
>我们的业务量越来越大，而要能应对越来越大的业务量，一台机器的性能已经无法满足了，我们需要多台机器才能应对大规模的应用场景。所以，我们需要垂直或是水平拆分业务系统，让其变成一个分布式的架构。

* 加强系统可用
>我们的业务越来越关键，需要提高整个系统架构的可用性，这就意味着架构中不能存在单点故障。这样，整个系统不会因为一台机器出故障而导致整体不可用。所以，需要通过分布式架构来冗余系统以消除单点故障，从而提高系统的可用性。

#### 优势
* 因为模块化，所以系统模块重用度更高；
* 因为软件服务模块被拆分，开发和发布速度可以并行而变得更快；
* 系统扩展性更高；
* 团队协作流程也会得到改善；
* ......

#### 问题
* 架构设计变得复杂（尤其是其中的分布式事务）。
* 部署单个服务会比较快，但是如果一次部署需要多个服务，部署会变得复杂。
* 系统的吞吐量会变大，但是响应时间会变长。
* 运维复杂度会因为服务变多而变得很复杂。
* 架构复杂导致学习曲线变大。
* 测试和查错的复杂度增大。
* 技术可以很多样，这会带来维护和运维的复杂度。
* 管理分布式系统中的服务和调度变得困难和复杂。

#### CAP定律
* 一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。
* 当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。
* 提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。
* 然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。
*  总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。

#### ACID
> 关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：

* Atomicity [ˌætəˈmɪsɪti]原子性：一个事务中所有操作都必须全部完成，要么全部不完成。
* Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。
* Isolation [ˌaɪsəˈleʃən]隔离层. 事务将假定只有它自己在操作数据库，彼此不知晓。
* Durability [ˌdjʊrəˈbɪlətɪ]. 一旦事务完成，就不能返回。
* 跨数据库两段提交事务：2PC (two-phase[fez] commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。

#### BASE模型

* BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：
* Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库)
* Soft state软状态 状态可以有一段时间不同步，异步。
* Eventually [ɪˈvɛntʃuəli] consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。
* BASE思想的主要实现有
  - 按功能划分数据库
  - sharding碎片
* BASE思想主要强调基本的可用性，如果你需要High 可用性，也就是纯粹的高性能，那么就要以一致性或容忍性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。

#### 选择
* CA (consistency高一致性 + availability高可用性). 使用2pc 两阶段事务提交来保证。其缺点无法实现分区容错性，一旦某个操作失败，整个系统就出错，无法容忍(水至清则无鱼)。
* CP (consistency高一致性 + partition tolerance分区容错性). 使用Paxos来保证，可用性降低。
* AP (availability高可用性 + partition tolerance分区容错性). 使用Gossip等实现最终一致性，如Dynamo.

#### 隔离设计
* Bulkheads(隔板)
  - 用户来分离
  - 服务种类分离
> https://www.roncoo.com/course/view/b181d1862c68461c81298b8c9222922e

#### 异步通讯设计

> 前面所说的隔离设计通常都需要对系统做解耦设计，而把一个单体系统解耦，不单单是把业务功能拆分出来，正如上面所说，拆分完后还会面对很多的问题。其中一个重要的问题就是这些系统间的通讯。

* 通过订阅的方式
    > 这种情况下，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。
* 通过 Broker 的方式
    > 所谓 Broker，就是一个中间人，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。
* 事件驱动设计
    >上述的第二种和第三种方式就是比较著名的事件驱动架构（EDA – Event Driven Architecture [ˈɑ:rkɪtektʃə(r)] ）。正如前面所说，事件驱动最好是使用 Broker 方式，服务间通过交换消息来完成交流和整个流程的驱动。

#### 幂等性设计
* 全局 ID
* HTTP 的幂等性
> http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html

#### 服务的状态
* 无状态的服务 Stateless
* 有状态的服务 Stateful
* 服务状态的容错设计
  - cp系统Paxos

#### 补偿事务
* ACID 和 BASE
* 业务补偿

#### 重试设计
* 重试的场景
* 重试的策略
> https://github.com/spring-projects/spring-retry

#### 熔断设计
* 闭合（Closed）状态    
* 断开 (Open) 状态
* 半开（Half-Open）状态

#### 限流设计
* 限流的策略
* 计数器方式
* 队列算法
* 漏斗算法 Leaky Bucket
* 令牌桶算法 Token Bucket
* 基于响应时间的动态限流

#### 降级设计
* 牺牲
* 降低一致性。从强一致性变成最终一致性。
* 停止次要功能。停止访问不重要的功能，从而释放出更多的资源。
* 简化功能。把一些功能简化掉，比如，简化业务流程，或是不再返回全量数据，只返回部分数据。s